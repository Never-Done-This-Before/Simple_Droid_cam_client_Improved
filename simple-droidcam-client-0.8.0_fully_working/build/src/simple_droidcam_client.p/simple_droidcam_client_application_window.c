/* simple_droidcam_client_application_window.c generated by valac 0.56.6, the Vala compiler
 * generated from simple_droidcam_client_application_window.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; c-basic-offset: 2; tab-width: 2 -*-  */
/* simple_droidcam_client_application_window.vala
 *
 * Copyright 2020 Fernando Fernandez
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <stdio.h>
#include <glib/gi18n-lib.h>
#include "config.h"

#define SIMPLE_DROID_CAM_CLIENT_APPLICATION_WINDOW_device_name "DroidCam"
#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define SIMPLE_DROID_CAM_CLIENT_TYPE_APPLICATION_WINDOW (simple_droid_cam_client_application_window_get_type ())
#define SIMPLE_DROID_CAM_CLIENT_APPLICATION_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SIMPLE_DROID_CAM_CLIENT_TYPE_APPLICATION_WINDOW, SimpleDroidCamClientApplicationWindow))
#define SIMPLE_DROID_CAM_CLIENT_APPLICATION_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SIMPLE_DROID_CAM_CLIENT_TYPE_APPLICATION_WINDOW, SimpleDroidCamClientApplicationWindowClass))
#define SIMPLE_DROID_CAM_CLIENT_IS_APPLICATION_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SIMPLE_DROID_CAM_CLIENT_TYPE_APPLICATION_WINDOW))
#define SIMPLE_DROID_CAM_CLIENT_IS_APPLICATION_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SIMPLE_DROID_CAM_CLIENT_TYPE_APPLICATION_WINDOW))
#define SIMPLE_DROID_CAM_CLIENT_APPLICATION_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SIMPLE_DROID_CAM_CLIENT_TYPE_APPLICATION_WINDOW, SimpleDroidCamClientApplicationWindowClass))

typedef struct _SimpleDroidCamClientApplicationWindow SimpleDroidCamClientApplicationWindow;
typedef struct _SimpleDroidCamClientApplicationWindowClass SimpleDroidCamClientApplicationWindowClass;
typedef struct _SimpleDroidCamClientApplicationWindowPrivate SimpleDroidCamClientApplicationWindowPrivate;
enum  {
	SIMPLE_DROID_CAM_CLIENT_APPLICATION_WINDOW_0_PROPERTY,
	SIMPLE_DROID_CAM_CLIENT_APPLICATION_WINDOW_NUM_PROPERTIES
};
static GParamSpec* simple_droid_cam_client_application_window_properties[SIMPLE_DROID_CAM_CLIENT_APPLICATION_WINDOW_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_array_unref0(var) ((var == NULL) ? NULL : (var = (g_array_unref (var), NULL)))

struct _SimpleDroidCamClientApplicationWindow {
	GtkApplicationWindow parent_instance;
	SimpleDroidCamClientApplicationWindowPrivate * priv;
};

struct _SimpleDroidCamClientApplicationWindowClass {
	GtkApplicationWindowClass parent_class;
};

struct _SimpleDroidCamClientApplicationWindowPrivate {
	GtkButton* button_new_devices;
	GtkButton* button_connect_camera;
	GtkEntry* entry_v4ld;
	GtkEntry* entry_ip;
	GtkEntry* entry_newdevices;
	GtkEntry* entry_port;
	GtkEntry* entry_resolution;
	GtkImage* image_state;
	GtkMenuButton* menubutton;
	GtkSwitch* switch_vertical_flip;
	GtkSpinner* spinner_connecting;
	GSettings* settings;
	GSubprocess* ffmpeg;
};

static gint SimpleDroidCamClientApplicationWindow_private_offset;
static gpointer simple_droid_cam_client_application_window_parent_class = NULL;

VALA_EXTERN GType simple_droid_cam_client_application_window_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SimpleDroidCamClientApplicationWindow, g_object_unref)
VALA_EXTERN SimpleDroidCamClientApplicationWindow* simple_droid_cam_client_application_window_new (GtkApplication* app);
VALA_EXTERN SimpleDroidCamClientApplicationWindow* simple_droid_cam_client_application_window_construct (GType object_type,
                                                                                             GtkApplication* app);
static void simple_droid_cam_client_application_window_kill_ffmpeg (SimpleDroidCamClientApplicationWindow* self,
                                                             GtkWindow* window);
static void _simple_droid_cam_client_application_window_kill_ffmpeg_gtk_application_window_removed (GtkApplication* _sender,
                                                                                             GtkWindow* window,
                                                                                             gpointer self);
static void simple_droid_cam_client_application_window_create_menu (SimpleDroidCamClientApplicationWindow* self);
static void simple_droid_cam_client_application_window_button_connect_camera_clicked (SimpleDroidCamClientApplicationWindow* self);
static gboolean simple_droid_cam_client_application_window_module_loaded (SimpleDroidCamClientApplicationWindow* self);
static void simple_droid_cam_client_application_window_load_module (SimpleDroidCamClientApplicationWindow* self);
static void simple_droid_cam_client_application_window_connect_camera (SimpleDroidCamClientApplicationWindow* self);
static void _simple_droid_cam_client_application_window_button_connect_camera_clicked_gtk_button_clicked (GtkButton* _sender,
                                                                                                   gpointer self);
static void simple_droid_cam_client_application_window_button_new_devices_clicked (SimpleDroidCamClientApplicationWindow* self);
static void _simple_droid_cam_client_application_window_button_new_devices_clicked_gtk_button_clicked (GtkButton* _sender,
                                                                                                gpointer self);
static void _g_free0_ (gpointer var);
static void _vala_gchar_free_function_content_of (gpointer data);
static void ___lambda7_ (SimpleDroidCamClientApplicationWindow* self);
static void simple_droid_cam_client_application_window_hide_spinner (SimpleDroidCamClientApplicationWindow* self);
static void ____lambda7__gasync_ready_callback (GObject* source_object,
                                         GAsyncResult* res,
                                         gpointer self);
static void simple_droid_cam_client_application_window_show_spinner (SimpleDroidCamClientApplicationWindow* self);
static gboolean ___lambda8_ (SimpleDroidCamClientApplicationWindow* self);
static gboolean ____lambda8__gsource_func (gpointer self);
static void __lambda5_ (SimpleDroidCamClientApplicationWindow* self);
static void ___lambda5__g_simple_action_activate (GSimpleAction* _sender,
                                           GVariant* parameter,
                                           gpointer self);
static void __lambda6_ (SimpleDroidCamClientApplicationWindow* self);
static void simple_droid_cam_client_application_window_about (SimpleDroidCamClientApplicationWindow* self);
static void ___lambda6__g_simple_action_activate (GSimpleAction* _sender,
                                           GVariant* parameter,
                                           gpointer self);
static void simple_droid_cam_client_application_window_finalize (GObject * obj);
static GType simple_droid_cam_client_application_window_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static inline gpointer
simple_droid_cam_client_application_window_get_instance_private (SimpleDroidCamClientApplicationWindow* self)
{
	return G_STRUCT_MEMBER_P (self, SimpleDroidCamClientApplicationWindow_private_offset);
}

static void
_simple_droid_cam_client_application_window_kill_ffmpeg_gtk_application_window_removed (GtkApplication* _sender,
                                                                                        GtkWindow* window,
                                                                                        gpointer self)
{
	simple_droid_cam_client_application_window_kill_ffmpeg ((SimpleDroidCamClientApplicationWindow*) self, window);
}

SimpleDroidCamClientApplicationWindow*
simple_droid_cam_client_application_window_construct (GType object_type,
                                                      GtkApplication* app)
{
	SimpleDroidCamClientApplicationWindow * self = NULL;
	GtkApplication* _tmp0_;
	GtkApplication* _tmp1_;
	GSettings* _tmp2_;
	GtkEntry* _tmp3_;
	GSettings* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	GtkEntry* _tmp7_;
	GSettings* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	GtkEntry* _tmp11_;
	GSettings* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	GtkEntry* _tmp15_;
	GSettings* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	GtkEntry* _tmp19_;
	GSettings* _tmp20_;
	gchar* _tmp21_;
	gchar* _tmp22_;
	GtkSwitch* _tmp23_;
	GSettings* _tmp24_;
	g_return_val_if_fail (app != NULL, NULL);
	self = (SimpleDroidCamClientApplicationWindow*) g_object_new (object_type, "application", app, NULL);
	_tmp0_ = gtk_window_get_application ((GtkWindow*) self);
	_tmp1_ = _tmp0_;
	g_signal_connect_object (_tmp1_, "window-removed", (GCallback) _simple_droid_cam_client_application_window_kill_ffmpeg_gtk_application_window_removed, self, 0);
	_tmp2_ = g_settings_new ("ar.com.softwareperonista.SimpleDroidCamClient");
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp2_;
	_tmp3_ = self->priv->entry_ip;
	_tmp4_ = self->priv->settings;
	_tmp5_ = g_settings_get_string (_tmp4_, "ip");
	_tmp6_ = _tmp5_;
	gtk_editable_set_text ((GtkEditable*) _tmp3_, _tmp6_);
	_g_free0 (_tmp6_);
	_tmp7_ = self->priv->entry_v4ld;
	_tmp8_ = self->priv->settings;
	_tmp9_ = g_settings_get_string (_tmp8_, "v4ld");
	_tmp10_ = _tmp9_;
	gtk_editable_set_text ((GtkEditable*) _tmp7_, _tmp10_);
	_g_free0 (_tmp10_);
	_tmp11_ = self->priv->entry_newdevices;
	_tmp12_ = self->priv->settings;
	_tmp13_ = g_settings_get_string (_tmp12_, "newdevices");
	_tmp14_ = _tmp13_;
	gtk_editable_set_text ((GtkEditable*) _tmp11_, _tmp14_);
	_g_free0 (_tmp14_);
	_tmp15_ = self->priv->entry_port;
	_tmp16_ = self->priv->settings;
	_tmp17_ = g_settings_get_string (_tmp16_, "port");
	_tmp18_ = _tmp17_;
	gtk_editable_set_text ((GtkEditable*) _tmp15_, _tmp18_);
	_g_free0 (_tmp18_);
	_tmp19_ = self->priv->entry_resolution;
	_tmp20_ = self->priv->settings;
	_tmp21_ = g_settings_get_string (_tmp20_, "resolution");
	_tmp22_ = _tmp21_;
	gtk_editable_set_text ((GtkEditable*) _tmp19_, _tmp22_);
	_g_free0 (_tmp22_);
	_tmp23_ = self->priv->switch_vertical_flip;
	_tmp24_ = self->priv->settings;
	gtk_switch_set_active (_tmp23_, g_settings_get_boolean (_tmp24_, "vertical-flip"));
	_g_object_unref0 (self->priv->ffmpeg);
	self->priv->ffmpeg = NULL;
	simple_droid_cam_client_application_window_create_menu (self);
	return self;
}

SimpleDroidCamClientApplicationWindow*
simple_droid_cam_client_application_window_new (GtkApplication* app)
{
	return simple_droid_cam_client_application_window_construct (SIMPLE_DROID_CAM_CLIENT_TYPE_APPLICATION_WINDOW, app);
}

static void
simple_droid_cam_client_application_window_button_connect_camera_clicked (SimpleDroidCamClientApplicationWindow* self)
{
	GSubprocess* _tmp0_;
	g_return_if_fail (self != NULL);
	if (!simple_droid_cam_client_application_window_module_loaded (self)) {
		simple_droid_cam_client_application_window_load_module (self);
	}
	_tmp0_ = self->priv->ffmpeg;
	if (_tmp0_ == NULL) {
		simple_droid_cam_client_application_window_connect_camera (self);
	} else {
		simple_droid_cam_client_application_window_kill_ffmpeg (self, (GtkWindow*) self);
	}
}

static void
_simple_droid_cam_client_application_window_button_connect_camera_clicked_gtk_button_clicked (GtkButton* _sender,
                                                                                              gpointer self)
{
	simple_droid_cam_client_application_window_button_connect_camera_clicked ((SimpleDroidCamClientApplicationWindow*) self);
}

static gchar*
string_slice (const gchar* self,
              glong start,
              glong end)
{
	glong string_length = 0L;
	gint _tmp0_;
	gint _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gchar* _tmp4_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	if (start < ((glong) 0)) {
		start = string_length + start;
	}
	if (end < ((glong) 0)) {
		end = string_length + end;
	}
	if (start >= ((glong) 0)) {
		_tmp2_ = start <= string_length;
	} else {
		_tmp2_ = FALSE;
	}
	g_return_val_if_fail (_tmp2_, NULL);
	if (end >= ((glong) 0)) {
		_tmp3_ = end <= string_length;
	} else {
		_tmp3_ = FALSE;
	}
	g_return_val_if_fail (_tmp3_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	_tmp4_ = g_strndup (((gchar*) self) + start, (gsize) (end - start));
	result = _tmp4_;
	return result;
}

static void
simple_droid_cam_client_application_window_button_new_devices_clicked (SimpleDroidCamClientApplicationWindow* self)
{
	gchar* standard_outputs = NULL;
	gchar* _tmp0_;
	gchar* command6 = NULL;
	gchar* _tmp1_;
	gchar* command7 = NULL;
	gchar* _tmp2_;
	gchar* command8 = NULL;
	GtkEntry* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("");
	standard_outputs = _tmp0_;
	_tmp1_ = g_strdup ("pkexec rmmod v4l2loopback ");
	command6 = _tmp1_;
	_tmp2_ = g_strdup ("sleep 1");
	command7 = _tmp2_;
	_tmp3_ = self->priv->entry_newdevices;
	_tmp4_ = gtk_editable_get_text ((GtkEditable*) _tmp3_);
	_tmp5_ = g_strconcat ("pkexec  modprobe v4l2loopback devices=", _tmp4_, NULL);
	command8 = _tmp5_;
	{
		gchar* _tmp6_ = NULL;
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		gchar* _tmp11_;
		g_spawn_command_line_sync (command6, &_tmp6_, NULL, NULL, &_inner_error0_);
		_g_free0 (standard_outputs);
		standard_outputs = _tmp6_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_SPAWN_ERROR) {
				goto __catch0_g_spawn_error;
			}
			_g_free0 (command8);
			_g_free0 (command7);
			_g_free0 (command6);
			_g_free0 (standard_outputs);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
		_tmp7_ = standard_outputs;
		_tmp8_ = standard_outputs;
		_tmp9_ = strlen (_tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = string_slice (_tmp7_, (glong) 0, (glong) (_tmp10_ - 1));
		_g_free0 (standard_outputs);
		standard_outputs = _tmp11_;
	}
	goto __finally0;
	__catch0_g_spawn_error:
	{
		GError* spawnCaughtError = NULL;
		FILE* _tmp12_;
		GError* _tmp13_;
		const gchar* _tmp14_;
		spawnCaughtError = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp12_ = stderr;
		_tmp13_ = spawnCaughtError;
		_tmp14_ = _tmp13_->message;
		fprintf (_tmp12_, "There was an error spawining the process. Details: %s", _tmp14_);
		_g_error_free0 (spawnCaughtError);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (command8);
		_g_free0 (command7);
		_g_free0 (command6);
		_g_free0 (standard_outputs);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	{
		gchar* _tmp15_ = NULL;
		const gchar* _tmp16_;
		const gchar* _tmp17_;
		gint _tmp18_;
		gint _tmp19_;
		gchar* _tmp20_;
		g_spawn_command_line_sync (command7, &_tmp15_, NULL, NULL, &_inner_error0_);
		_g_free0 (standard_outputs);
		standard_outputs = _tmp15_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_SPAWN_ERROR) {
				goto __catch1_g_spawn_error;
			}
			_g_free0 (command8);
			_g_free0 (command7);
			_g_free0 (command6);
			_g_free0 (standard_outputs);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
		_tmp16_ = standard_outputs;
		_tmp17_ = standard_outputs;
		_tmp18_ = strlen (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = string_slice (_tmp16_, (glong) 0, (glong) (_tmp19_ - 1));
		_g_free0 (standard_outputs);
		standard_outputs = _tmp20_;
	}
	goto __finally1;
	__catch1_g_spawn_error:
	{
		GError* spawnCaughtError = NULL;
		FILE* _tmp21_;
		GError* _tmp22_;
		const gchar* _tmp23_;
		spawnCaughtError = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp21_ = stderr;
		_tmp22_ = spawnCaughtError;
		_tmp23_ = _tmp22_->message;
		fprintf (_tmp21_, "There was an error spawining the process. Details: %s", _tmp23_);
		_g_error_free0 (spawnCaughtError);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (command8);
		_g_free0 (command7);
		_g_free0 (command6);
		_g_free0 (standard_outputs);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	{
		gchar* _tmp24_ = NULL;
		const gchar* _tmp25_;
		const gchar* _tmp26_;
		gint _tmp27_;
		gint _tmp28_;
		gchar* _tmp29_;
		g_spawn_command_line_sync (command8, &_tmp24_, NULL, NULL, &_inner_error0_);
		_g_free0 (standard_outputs);
		standard_outputs = _tmp24_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_SPAWN_ERROR) {
				goto __catch2_g_spawn_error;
			}
			_g_free0 (command8);
			_g_free0 (command7);
			_g_free0 (command6);
			_g_free0 (standard_outputs);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
		_tmp25_ = standard_outputs;
		_tmp26_ = standard_outputs;
		_tmp27_ = strlen (_tmp26_);
		_tmp28_ = _tmp27_;
		_tmp29_ = string_slice (_tmp25_, (glong) 0, (glong) (_tmp28_ - 1));
		_g_free0 (standard_outputs);
		standard_outputs = _tmp29_;
	}
	goto __finally2;
	__catch2_g_spawn_error:
	{
		GError* spawnCaughtError = NULL;
		FILE* _tmp30_;
		GError* _tmp31_;
		const gchar* _tmp32_;
		spawnCaughtError = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp30_ = stderr;
		_tmp31_ = spawnCaughtError;
		_tmp32_ = _tmp31_->message;
		fprintf (_tmp30_, "There was an error spawining the process. Details: %s", _tmp32_);
		_g_error_free0 (spawnCaughtError);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (command8);
		_g_free0 (command7);
		_g_free0 (command6);
		_g_free0 (standard_outputs);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_g_free0 (command8);
	_g_free0 (command7);
	_g_free0 (command6);
	_g_free0 (standard_outputs);
}

static void
_simple_droid_cam_client_application_window_button_new_devices_clicked_gtk_button_clicked (GtkButton* _sender,
                                                                                           gpointer self)
{
	simple_droid_cam_client_application_window_button_new_devices_clicked ((SimpleDroidCamClientApplicationWindow*) self);
}

static gchar*
bool_to_string (gboolean self)
{
	gchar* result;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}

static gboolean
simple_droid_cam_client_application_window_module_loaded (SimpleDroidCamClientApplicationWindow* self)
{
	gchar* command = NULL;
	GtkEntry* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* standard_output = NULL;
	gchar* _tmp6_;
	gboolean ret = FALSE;
	const gchar* _tmp18_;
	gchar* _tmp19_;
	gchar* _tmp20_;
	GError* _inner_error0_ = NULL;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->entry_v4ld;
	_tmp1_ = gtk_editable_get_text ((GtkEditable*) _tmp0_);
	_tmp2_ = g_strconcat ("cat /sys/devices/virtual/video4linux/video", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat (_tmp3_, "/name", NULL);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	command = _tmp5_;
	_tmp6_ = g_strdup ("");
	standard_output = _tmp6_;
	ret = FALSE;
	{
		gchar* _tmp7_ = NULL;
		const gchar* _tmp9_;
		const gchar* _tmp10_;
		gint _tmp11_;
		gint _tmp12_;
		gchar* _tmp13_;
		g_spawn_command_line_sync (command, &_tmp7_, NULL, NULL, &_inner_error0_);
		_g_free0 (standard_output);
		standard_output = _tmp7_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gboolean _tmp8_ = FALSE;
			if (_inner_error0_->domain == G_SPAWN_ERROR) {
				goto __catch0_g_spawn_error;
			}
			_g_free0 (standard_output);
			_g_free0 (command);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp8_;
		}
		_tmp9_ = standard_output;
		_tmp10_ = standard_output;
		_tmp11_ = strlen (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = string_slice (_tmp9_, (glong) 0, (glong) (_tmp12_ - 1));
		_g_free0 (standard_output);
		standard_output = _tmp13_;
	}
	goto __finally0;
	__catch0_g_spawn_error:
	{
		GError* spawnCaughtError = NULL;
		FILE* _tmp14_;
		GError* _tmp15_;
		const gchar* _tmp16_;
		spawnCaughtError = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp14_ = stderr;
		_tmp15_ = spawnCaughtError;
		_tmp16_ = _tmp15_->message;
		fprintf (_tmp14_, "There was an error spawining the process. Details: %s", _tmp16_);
		_g_error_free0 (spawnCaughtError);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp17_ = FALSE;
		_g_free0 (standard_output);
		_g_free0 (command);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp17_;
	}
	_tmp18_ = standard_output;
	if (g_strcmp0 (_tmp18_, SIMPLE_DROID_CAM_CLIENT_APPLICATION_WINDOW_device_name) == 0) {
		ret = TRUE;
	}
	_tmp19_ = bool_to_string (ret);
	_tmp20_ = _tmp19_;
	g_debug ("simple_droidcam_client_application_window.vala:136: %s", _tmp20_);
	_g_free0 (_tmp20_);
	result = ret;
	_g_free0 (standard_output);
	_g_free0 (command);
	return result;
}

static void
simple_droid_cam_client_application_window_load_module (SimpleDroidCamClientApplicationWindow* self)
{
	gchar* command = NULL;
	GtkEntry* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->entry_v4ld;
	_tmp1_ = gtk_editable_get_text ((GtkEditable*) _tmp0_);
	_tmp2_ = g_strconcat ("pkexec modprobe v4l2loopback exclusive_caps=1 video_nr=", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat (_tmp3_, " ", NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat (_tmp5_, "card_label=", NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_strconcat (_tmp7_, SIMPLE_DROID_CAM_CLIENT_APPLICATION_WINDOW_device_name, NULL);
	_tmp9_ = _tmp8_;
	_tmp10_ = g_strconcat (_tmp9_, "", NULL);
	_tmp11_ = _tmp10_;
	_g_free0 (_tmp9_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	_g_free0 (_tmp3_);
	command = _tmp11_;
	{
		g_spawn_command_line_sync (command, NULL, NULL, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_SPAWN_ERROR) {
				goto __catch0_g_spawn_error;
			}
			_g_free0 (command);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	goto __finally0;
	__catch0_g_spawn_error:
	{
		GError* spawnCaughtError = NULL;
		FILE* _tmp12_;
		GError* _tmp13_;
		const gchar* _tmp14_;
		spawnCaughtError = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp12_ = stderr;
		_tmp13_ = spawnCaughtError;
		_tmp14_ = _tmp13_->message;
		fprintf (_tmp12_, "There was an error spawining the process. Details: %s", _tmp14_);
		_g_error_free0 (spawnCaughtError);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (command);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_g_free0 (command);
}

static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}

static void
_vala_gchar_free_function_content_of (gpointer data)
{
	gchar* self;
	self = *((gchar**) data);
	_g_free0_ (self);
}

static void
___lambda7_ (SimpleDroidCamClientApplicationWindow* self)
{
	GtkButton* _tmp0_;
	GtkImage* _tmp1_;
	_g_object_unref0 (self->priv->ffmpeg);
	self->priv->ffmpeg = NULL;
	_tmp0_ = self->priv->button_connect_camera;
	gtk_button_set_label (_tmp0_, "Connect");
	_tmp1_ = self->priv->image_state;
	gtk_image_set_from_icon_name (_tmp1_, "window-close-symbolic");
	simple_droid_cam_client_application_window_hide_spinner (self);
}

static void
____lambda7__gasync_ready_callback (GObject* source_object,
                                    GAsyncResult* res,
                                    gpointer self)
{
	___lambda7_ ((SimpleDroidCamClientApplicationWindow*) self);
	g_object_unref (self);
}

static gboolean
___lambda8_ (SimpleDroidCamClientApplicationWindow* self)
{
	GSubprocess* _tmp0_;
	gboolean result;
	_tmp0_ = self->priv->ffmpeg;
	if (_tmp0_ != NULL) {
		GSettings* _tmp1_;
		GtkEntry* _tmp2_;
		const gchar* _tmp3_;
		GSettings* _tmp4_;
		GtkEntry* _tmp5_;
		const gchar* _tmp6_;
		GSettings* _tmp7_;
		GtkEntry* _tmp8_;
		const gchar* _tmp9_;
		GSettings* _tmp10_;
		GtkSwitch* _tmp11_;
		gboolean _tmp12_;
		gboolean _tmp13_;
		GtkButton* _tmp14_;
		GtkImage* _tmp15_;
		_tmp1_ = self->priv->settings;
		_tmp2_ = self->priv->entry_ip;
		_tmp3_ = gtk_editable_get_text ((GtkEditable*) _tmp2_);
		g_settings_set_string (_tmp1_, "ip", _tmp3_);
		_tmp4_ = self->priv->settings;
		_tmp5_ = self->priv->entry_port;
		_tmp6_ = gtk_editable_get_text ((GtkEditable*) _tmp5_);
		g_settings_set_string (_tmp4_, "port", _tmp6_);
		_tmp7_ = self->priv->settings;
		_tmp8_ = self->priv->entry_resolution;
		_tmp9_ = gtk_editable_get_text ((GtkEditable*) _tmp8_);
		g_settings_set_string (_tmp7_, "resolution", _tmp9_);
		_tmp10_ = self->priv->settings;
		_tmp11_ = self->priv->switch_vertical_flip;
		_tmp12_ = gtk_switch_get_active (_tmp11_);
		_tmp13_ = _tmp12_;
		g_settings_set_boolean (_tmp10_, "vertical-flip", _tmp13_);
		_tmp14_ = self->priv->button_connect_camera;
		gtk_button_set_label (_tmp14_, "Disconnect");
		_tmp15_ = self->priv->image_state;
		gtk_image_set_from_icon_name (_tmp15_, "emblem-ok-symbolic");
		simple_droid_cam_client_application_window_hide_spinner (self);
	}
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
____lambda8__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda8_ ((SimpleDroidCamClientApplicationWindow*) self);
	return result;
}

static void
simple_droid_cam_client_application_window_connect_camera (SimpleDroidCamClientApplicationWindow* self)
{
	gchar* socket = NULL;
	GtkEntry* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	GtkEntry* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	GArray* args = NULL;
	GArray* _tmp8_;
	GArray* _tmp9_;
	gchar* _tmp10_;
	GArray* _tmp11_;
	gchar* _tmp12_;
	GArray* _tmp13_;
	const gchar* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	GtkEntry* _tmp19_;
	const gchar* _tmp20_;
	gchar* _tmp21_;
	GArray* _tmp22_;
	gchar* _tmp23_;
	GArray* _tmp24_;
	gchar* _tmp25_;
	GArray* _tmp26_;
	gchar* _tmp27_;
	GArray* _tmp28_;
	gchar* _tmp29_;
	GArray* _tmp30_;
	gchar* _tmp31_;
	GArray* _tmp32_;
	gchar* _tmp33_;
	GtkSwitch* _tmp34_;
	gboolean _tmp35_;
	gboolean _tmp36_;
	GArray* _tmp41_;
	GtkEntry* _tmp42_;
	const gchar* _tmp43_;
	gchar* _tmp44_;
	gchar** spawn_args = NULL;
	GArray* _tmp45_;
	gsize _tmp46_ = 0;
	gpointer* _tmp47_;
	gint spawn_args_length1;
	gint _spawn_args_size_;
	gchar* command = NULL;
	gchar** _tmp48_;
	gint _tmp48__length1;
	const gchar* _tmp49_;
	gchar* _tmp50_;
	const gchar* _tmp60_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->entry_ip;
	_tmp1_ = gtk_editable_get_text ((GtkEditable*) _tmp0_);
	_tmp2_ = g_strconcat (_tmp1_, ":", NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = self->priv->entry_port;
	_tmp5_ = gtk_editable_get_text ((GtkEditable*) _tmp4_);
	_tmp6_ = g_strconcat (_tmp3_, _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp3_);
	socket = _tmp7_;
	_tmp8_ = g_array_new (TRUE, TRUE, sizeof (gchar*));
	g_array_set_clear_func (_tmp8_, (GDestroyNotify) _vala_gchar_free_function_content_of);
	args = _tmp8_;
	_tmp9_ = args;
	_tmp10_ = g_strdup ("ffmpeg");
	g_array_append_val (_tmp9_, _tmp10_);
	_tmp11_ = args;
	_tmp12_ = g_strdup ("-i");
	g_array_append_val (_tmp11_, _tmp12_);
	_tmp13_ = args;
	_tmp14_ = socket;
	_tmp15_ = g_strconcat ("http://", _tmp14_, NULL);
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strconcat (_tmp16_, "/mjpegfeed?", NULL);
	_tmp18_ = _tmp17_;
	_tmp19_ = self->priv->entry_resolution;
	_tmp20_ = gtk_editable_get_text ((GtkEditable*) _tmp19_);
	_tmp21_ = g_strconcat (_tmp18_, _tmp20_, NULL);
	g_array_append_val (_tmp13_, _tmp21_);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp16_);
	_tmp22_ = args;
	_tmp23_ = g_strdup ("-vcodec");
	g_array_append_val (_tmp22_, _tmp23_);
	_tmp24_ = args;
	_tmp25_ = g_strdup ("rawvideo");
	g_array_append_val (_tmp24_, _tmp25_);
	_tmp26_ = args;
	_tmp27_ = g_strdup ("-pix_fmt");
	g_array_append_val (_tmp26_, _tmp27_);
	_tmp28_ = args;
	_tmp29_ = g_strdup ("yuv420p");
	g_array_append_val (_tmp28_, _tmp29_);
	_tmp30_ = args;
	_tmp31_ = g_strdup ("-f");
	g_array_append_val (_tmp30_, _tmp31_);
	_tmp32_ = args;
	_tmp33_ = g_strdup ("v4l2");
	g_array_append_val (_tmp32_, _tmp33_);
	_tmp34_ = self->priv->switch_vertical_flip;
	_tmp35_ = gtk_switch_get_active (_tmp34_);
	_tmp36_ = _tmp35_;
	if (_tmp36_) {
		GArray* _tmp37_;
		gchar* _tmp38_;
		GArray* _tmp39_;
		gchar* _tmp40_;
		_tmp37_ = args;
		_tmp38_ = g_strdup ("-vf");
		g_array_append_val (_tmp37_, _tmp38_);
		_tmp39_ = args;
		_tmp40_ = g_strdup ("vflip");
		g_array_append_val (_tmp39_, _tmp40_);
	}
	_tmp41_ = args;
	_tmp42_ = self->priv->entry_v4ld;
	_tmp43_ = gtk_editable_get_text ((GtkEditable*) _tmp42_);
	_tmp44_ = g_strconcat ("/dev/video", _tmp43_, NULL);
	g_array_append_val (_tmp41_, _tmp44_);
	_tmp45_ = args;
	_tmp47_ = g_array_steal (_tmp45_, &_tmp46_);
	spawn_args = _tmp47_;
	spawn_args_length1 = _tmp46_;
	_spawn_args_size_ = spawn_args_length1;
	_tmp48_ = spawn_args;
	_tmp48__length1 = spawn_args_length1;
	_tmp49_ = _tmp48_[0];
	_tmp50_ = g_strdup (_tmp49_);
	command = _tmp50_;
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp51_ = FALSE;
			_tmp51_ = TRUE;
			while (TRUE) {
				gchar** _tmp53_;
				gint _tmp53__length1;
				const gchar* _tmp54_;
				gchar** _tmp55_;
				gint _tmp55__length1;
				const gchar* _tmp56_;
				gchar* _tmp57_;
				gchar* _tmp58_;
				gchar* _tmp59_;
				if (!_tmp51_) {
					gint _tmp52_;
					_tmp52_ = i;
					i = _tmp52_ + 1;
				}
				_tmp51_ = FALSE;
				_tmp53_ = spawn_args;
				_tmp53__length1 = spawn_args_length1;
				if (!(i < _tmp53__length1)) {
					break;
				}
				_tmp54_ = command;
				_tmp55_ = spawn_args;
				_tmp55__length1 = spawn_args_length1;
				_tmp56_ = _tmp55_[i];
				_tmp57_ = g_strconcat (" ", _tmp56_, NULL);
				_tmp58_ = _tmp57_;
				_tmp59_ = g_strconcat (_tmp54_, _tmp58_, NULL);
				_g_free0 (command);
				command = _tmp59_;
				_g_free0 (_tmp58_);
			}
		}
	}
	_tmp60_ = command;
	g_debug ("simple_droidcam_client_application_window.vala:176: %s", _tmp60_);
	{
		GSubprocess* _tmp61_ = NULL;
		gchar** _tmp62_;
		gint _tmp62__length1;
		GSubprocess* _tmp63_;
		GSubprocess* _tmp64_;
		GSubprocess* _tmp65_;
		GtkButton* _tmp66_;
		_tmp62_ = spawn_args;
		_tmp62__length1 = spawn_args_length1;
		_tmp63_ = g_subprocess_newv (_tmp62_, G_SUBPROCESS_FLAGS_NONE, &_inner_error0_);
		_tmp61_ = _tmp63_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp64_ = _tmp61_;
		_tmp61_ = NULL;
		_g_object_unref0 (self->priv->ffmpeg);
		self->priv->ffmpeg = _tmp64_;
		_tmp65_ = self->priv->ffmpeg;
		g_subprocess_wait_async (_tmp65_, NULL, ____lambda7__gasync_ready_callback, g_object_ref (self));
		_tmp66_ = self->priv->button_connect_camera;
		gtk_button_set_label (_tmp66_, "Connecting...");
		simple_droid_cam_client_application_window_show_spinner (self);
		g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 1, ____lambda8__gsource_func, g_object_ref (self), g_object_unref);
		_g_object_unref0 (_tmp61_);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp67_;
		GError* _tmp68_;
		const gchar* _tmp69_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp67_ = stderr;
		_tmp68_ = e;
		_tmp69_ = _tmp68_->message;
		fprintf (_tmp67_, "There was an error spawining the process. Details: %s", _tmp69_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (command);
		spawn_args = (_vala_array_free (spawn_args, spawn_args_length1, (GDestroyNotify) g_free), NULL);
		_g_array_unref0 (args);
		_g_free0 (socket);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_g_free0 (command);
	spawn_args = (_vala_array_free (spawn_args, spawn_args_length1, (GDestroyNotify) g_free), NULL);
	_g_array_unref0 (args);
	_g_free0 (socket);
}

static void
simple_droid_cam_client_application_window_kill_ffmpeg (SimpleDroidCamClientApplicationWindow* self,
                                                        GtkWindow* window)
{
	GSubprocess* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (window != NULL);
	_tmp0_ = self->priv->ffmpeg;
	if (_tmp0_ != NULL) {
		GSubprocess* _tmp1_;
		_tmp1_ = self->priv->ffmpeg;
		g_subprocess_force_exit (_tmp1_);
	}
}

static void
__lambda5_ (SimpleDroidCamClientApplicationWindow* self)
{
	gtk_window_close ((GtkWindow*) self);
}

static void
___lambda5__g_simple_action_activate (GSimpleAction* _sender,
                                      GVariant* parameter,
                                      gpointer self)
{
	__lambda5_ ((SimpleDroidCamClientApplicationWindow*) self);
}

static void
__lambda6_ (SimpleDroidCamClientApplicationWindow* self)
{
	simple_droid_cam_client_application_window_about (self);
}

static void
___lambda6__g_simple_action_activate (GSimpleAction* _sender,
                                      GVariant* parameter,
                                      gpointer self)
{
	__lambda6_ ((SimpleDroidCamClientApplicationWindow*) self);
}

static void
simple_droid_cam_client_application_window_create_menu (SimpleDroidCamClientApplicationWindow* self)
{
	GtkBuilder* builder = NULL;
	GtkBuilder* _tmp0_;
	GSimpleAction* action = NULL;
	GSimpleAction* _tmp4_;
	GSimpleAction* _tmp5_;
	GSimpleAction* _tmp6_;
	GtkApplication* _tmp7_;
	GtkApplication* _tmp8_;
	GSimpleAction* _tmp9_;
	GSimpleAction* _tmp10_;
	GSimpleAction* _tmp11_;
	GSimpleAction* _tmp12_;
	GtkApplication* _tmp13_;
	GtkApplication* _tmp14_;
	GSimpleAction* _tmp15_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_builder_new ();
	builder = _tmp0_;
	{
		GtkMenuButton* _tmp1_;
		GObject* _tmp2_;
		gtk_builder_add_from_resource (builder, "/ar/com/softwareperonista/simple_droidcam_client/ui/simple_droidcam_cl" \
"ient_main_menu.ui", &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp1_ = self->priv->menubutton;
		_tmp2_ = gtk_builder_get_object (builder, "main-menu");
		gtk_menu_button_set_menu_model (_tmp1_, (GMenuModel*) (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, g_menu_get_type ()) ? ((GMenu*) _tmp2_) : NULL));
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp3_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp3_ = e->message;
		g_error ("simple_droidcam_client_application_window.vala:220: loading ui file: %" \
"s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (builder);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp4_ = g_simple_action_new ("quit", NULL);
	action = _tmp4_;
	_tmp5_ = action;
	g_simple_action_set_enabled (_tmp5_, TRUE);
	_tmp6_ = action;
	g_signal_connect_object (_tmp6_, "activate", (GCallback) ___lambda5__g_simple_action_activate, self, 0);
	_tmp7_ = gtk_window_get_application ((GtkWindow*) self);
	_tmp8_ = _tmp7_;
	_tmp9_ = action;
	g_action_map_add_action ((GActionMap*) _tmp8_, (GAction*) _tmp9_);
	_tmp10_ = g_simple_action_new ("about", NULL);
	_g_object_unref0 (action);
	action = _tmp10_;
	_tmp11_ = action;
	g_simple_action_set_enabled (_tmp11_, TRUE);
	_tmp12_ = action;
	g_signal_connect_object (_tmp12_, "activate", (GCallback) ___lambda6__g_simple_action_activate, self, 0);
	_tmp13_ = gtk_window_get_application ((GtkWindow*) self);
	_tmp14_ = _tmp13_;
	_tmp15_ = action;
	g_action_map_add_action ((GActionMap*) _tmp14_, (GAction*) _tmp15_);
	_g_object_unref0 (action);
	_g_object_unref0 (builder);
}

static void
simple_droid_cam_client_application_window_about (SimpleDroidCamClientApplicationWindow* self)
{
	gchar** authors = NULL;
	gchar* _tmp0_;
	gchar** _tmp1_;
	gint authors_length1;
	gint _authors_size_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("Fernando Fernandez <fernando@softwareperonista.com.ar>");
	_tmp1_ = g_new0 (gchar*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	authors = _tmp1_;
	authors_length1 = 1;
	_authors_size_ = authors_length1;
	_tmp2_ = g_strconcat (_ ("About"), " Simple DroidCam Client", NULL);
	_tmp3_ = _tmp2_;
	gtk_show_about_dialog ((GtkWindow*) self, "authors", authors, "program-name", "Simple Droidcam Client", "title", _tmp3_, "comments", _ ("A simple DroidCam client"), "copyright", "Copyright 2020-2021 Fernando Fernández", "license-type", GTK_LICENSE_GPL_3_0, "logo-icon-name", "ar.com.softwareperonista.SimpleDroidCamClient", "version", VERSION, "website", "https://gitlab.com/tarmaciltur/simple-droidcam-client", "wrap-license", TRUE, NULL);
	_g_free0 (_tmp3_);
	authors = (_vala_array_free (authors, authors_length1, (GDestroyNotify) g_free), NULL);
}

static void
simple_droid_cam_client_application_window_show_spinner (SimpleDroidCamClientApplicationWindow* self)
{
	GtkImage* _tmp0_;
	GtkSpinner* _tmp1_;
	GtkSpinner* _tmp2_;
	GtkButton* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->image_state;
	gtk_widget_set_visible ((GtkWidget*) _tmp0_, FALSE);
	_tmp1_ = self->priv->spinner_connecting;
	gtk_widget_set_visible ((GtkWidget*) _tmp1_, TRUE);
	_tmp2_ = self->priv->spinner_connecting;
	gtk_spinner_start (_tmp2_);
	_tmp3_ = self->priv->button_connect_camera;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp3_, FALSE);
}

static void
simple_droid_cam_client_application_window_hide_spinner (SimpleDroidCamClientApplicationWindow* self)
{
	GtkImage* _tmp0_;
	GtkSpinner* _tmp1_;
	GtkSpinner* _tmp2_;
	GtkButton* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->image_state;
	gtk_widget_set_visible ((GtkWidget*) _tmp0_, TRUE);
	_tmp1_ = self->priv->spinner_connecting;
	gtk_widget_set_visible ((GtkWidget*) _tmp1_, FALSE);
	_tmp2_ = self->priv->spinner_connecting;
	gtk_spinner_stop (_tmp2_);
	_tmp3_ = self->priv->button_connect_camera;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp3_, TRUE);
}

static void
simple_droid_cam_client_application_window_class_init (SimpleDroidCamClientApplicationWindowClass * klass,
                                                       gpointer klass_data)
{
	simple_droid_cam_client_application_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &SimpleDroidCamClientApplicationWindow_private_offset);
	G_OBJECT_CLASS (klass)->finalize = simple_droid_cam_client_application_window_finalize;
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/ar/com/softwareperonista/simple_droidcam_client/ui/simple_droidcam_client_application_window.ui");
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "button_new_devices", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, button_new_devices));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "button_connect_camera", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, button_connect_camera));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "entry_v4ld", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, entry_v4ld));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "entry_ip", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, entry_ip));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "entry_newdevices", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, entry_newdevices));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "entry_port", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, entry_port));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "entry_resolution", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, entry_resolution));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "image_state", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, image_state));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "menubutton", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, menubutton));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "switch_vertical_flip", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, switch_vertical_flip));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "spinner_connecting", FALSE, SimpleDroidCamClientApplicationWindow_private_offset + G_STRUCT_OFFSET (SimpleDroidCamClientApplicationWindowPrivate, spinner_connecting));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "button_connect_camera_clicked", G_CALLBACK(_simple_droid_cam_client_application_window_button_connect_camera_clicked_gtk_button_clicked));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "button_new_devices_clicked", G_CALLBACK(_simple_droid_cam_client_application_window_button_new_devices_clicked_gtk_button_clicked));
}

static void
simple_droid_cam_client_application_window_instance_init (SimpleDroidCamClientApplicationWindow * self,
                                                          gpointer klass)
{
	self->priv = simple_droid_cam_client_application_window_get_instance_private (self);
	gtk_widget_init_template (GTK_WIDGET (self));
}

static void
simple_droid_cam_client_application_window_finalize (GObject * obj)
{
	SimpleDroidCamClientApplicationWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SIMPLE_DROID_CAM_CLIENT_TYPE_APPLICATION_WINDOW, SimpleDroidCamClientApplicationWindow);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->ffmpeg);
	G_OBJECT_CLASS (simple_droid_cam_client_application_window_parent_class)->finalize (obj);
}

static GType
simple_droid_cam_client_application_window_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (SimpleDroidCamClientApplicationWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) simple_droid_cam_client_application_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SimpleDroidCamClientApplicationWindow), 0, (GInstanceInitFunc) simple_droid_cam_client_application_window_instance_init, NULL };
	GType simple_droid_cam_client_application_window_type_id;
	simple_droid_cam_client_application_window_type_id = g_type_register_static (gtk_application_window_get_type (), "SimpleDroidCamClientApplicationWindow", &g_define_type_info, 0);
	SimpleDroidCamClientApplicationWindow_private_offset = g_type_add_instance_private (simple_droid_cam_client_application_window_type_id, sizeof (SimpleDroidCamClientApplicationWindowPrivate));
	return simple_droid_cam_client_application_window_type_id;
}

GType
simple_droid_cam_client_application_window_get_type (void)
{
	static volatile gsize simple_droid_cam_client_application_window_type_id__once = 0;
	if (g_once_init_enter (&simple_droid_cam_client_application_window_type_id__once)) {
		GType simple_droid_cam_client_application_window_type_id;
		simple_droid_cam_client_application_window_type_id = simple_droid_cam_client_application_window_get_type_once ();
		g_once_init_leave (&simple_droid_cam_client_application_window_type_id__once, simple_droid_cam_client_application_window_type_id);
	}
	return simple_droid_cam_client_application_window_type_id__once;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

